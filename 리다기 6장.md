1. 컴포넌트 반복

- 자바스크립트 배열 객체인 map함수를 사용하여 반복되는 컴포넌트 렌더링 가능

1-1. `문법`

```js
arr.map(callback, [thisArg])

// callback : 새로운 배열의 요소를 생성하는 함수
//  - currentValue : 현재 처리하고 있는 요소
//  - index : 현재 처리하고 있는 요소의 index 값
//  - array : 현재 처리하고 있는 원본 배열
// thisArg(선택 항목) : callback 함수 내부에서 사용할 this 레퍼런스

// ex)

const numbers = [1, 2, 3, 4, 5];
const result = numbers.map(num => num * num);
console.log(result);
```

1-2. 데이터 배열을 컴포넌트 배열로 변환하기

```js
// IterationSample.js
import React from 'react';

const IterationSample = () =>{
    const names = ['눈사람', '얼음', '눈', '바람'];
    const nameList = names.map(name => <li>{name}</li>);
    return <ul>{nameList}</ul>;
};

export default IterationSample;

// App.js
import React, {Component} from 'react';
import IterationSample from './IterationSample';

class App extends Component{
    render() {
        return (
            <IterationSample/>
            );
        }
    }
export default App;

`key prop가 없어 제대로 된 동작 x`
```

1-3. key

- key 값을 설정할 때는 map 함수의 인자로 전달되는 함수 내부에서 컴포넌트 props를 설정하듯이 설정하면 됨

- key 값은 언제나 유일해야 하므로, 데이터가 가진 고유의 값이 key값으로 설정되어야 함

```js
// ex

const articleList = articleList.map(article => (
    <Article
        title = {article.title}
        writer = {article.writer}
        key = {article.id}
    />
));
```

- `고유번호가 없을 땐 map 함수에 전달되는 콜백 함수의 인수인 index 값 사용`

```js
// IterationSample.js
import React from 'react';

const IterationSample = () =>{
    const names = ['눈사람', '얼음', '눈', '바람'];
    const nameList = names.map((name, index) => <li key={index}>{name}</li>);
    return <ul>{nameList}</ul>;
};

export default IterationSample;
```

1-4. 고정배열을 렌더링하는 것이 아닌 동적배열 렌더링하기

```js
import React, { useState } from 'react';

const IterationSample = () => {
    const [names, setNames] = useState([    // 동적상태로 id값에 text 입력
        {id: 1, text: '눈사람'},
        {id: 2, text: '얼음'},
        {id: 3, text: '눈'},
        {id: 4, text: '바람'},
    ]);
    const [inputText, setInputText] = useState('');
    const [nextId, setNextId] = useState(5);    // 새로운 항목을 추가할 때 사용할 id

    const onChange = e => setInputText(e.target.value); // useState('') 값이 onChange 값에 들어감
    const onClick = () => {
        const nextNames = names.concat({
            id: nextId,
            text: inputText
        });
        setNextId(nextId + 1);      // id + 1 되고
        setNames(nextNames);        // 입력하는 값 들어가고
        setInputText('');           // 마찬가지로 입력하는 값 들어감
    };
    const onRemove = id => {        // id 값을 받고
        const nextNames = names.filter(name => name.id !== id); // name의 id 가 id와 같지 않을 때
        setNames(nextNames);
    };
    const namesList = names.map(name =>(
        <li key={name.id} onDoubleClick = {() => onRemove(name.id)}>    // 더블클릭되면 onRemove 함수 실행
            {name.text}
        </li>
    ));
    return (
        <>
        <input value = {inputText} onChange = {onChange} />
        <button onClick = {onClick}>추가</button>
        <ul>{namesList}</ul>
        </>
    );
};
export default IterationSample;
```