## 리액트
리액트 : 사용자 인터페이스를 쉽게 구성할 수 있게 도와주는 라이브러리
## 리액트 기본 사용 준비
```
<body>
    <div id="root"></div>
    <script tye="text/bable">
    </script>
```
_바벨 Babel_ : 리액트 라이브러리는 리액트를 위해 가발된 자바스크립트 확장 문법을 사용함 &rarr; 이 문법을 사용하려면 바벨 라이브러리를 읽어들이고 적용할 부분 지정

## 루트 컴포넌트 출력하기
_컴포넌트_ : 리액트에서 화면에 출력되는 요소
_루트 컴포넌트_ : 가장 최상위에 배치하는 컴포넌트

_컴포넌트 생성하기_
``` <컴포넌트 이름></컴포넌트 이름> ```

_컴포넌트 출력하기_ : ReactDOM.render( ) 메소드 사용
``` ReactDOM.render(컴포넌트,컨테이너) ```
_컨테이너_ : 컴포넌트를 출력할 상자

# JSX
JSX(자바스크립트 확장 문법) : 자바스크립트 코드 내부에서 HTML코드를 사용할 수 있도록 도와주는 문법 / Babel이 jsx코드를 읽고 일반적인 자바스크립트 문법으로 변환한 뒤 실행해줌

## JSX 기본 문법
✔ 표현식을 출력할 때 { } 기호 사용 BUT 속성으로 표현식을 출력할 때 따옴표 사용하면 안됨❌
_표현식 출력하기_
```
<태그>{표현식}</태그>
<태그 속성={표현식}/>
```

예시)
```js
<div id="root"></div>
<script type="text/babel">
    //상수선언하기
    const name='구름'
    const imgUrl='http://image'
    //컴포넌트와 컨테이너 생성
    const component=
        <div>
            <h1>{name}님 안녕하세요! </h1>
            <img src={imgUrl}/> //이때 따옴표 헷갈리면 안됨
        </div>
        const container=document.getElementById('root')
        //출력하기
        ReactDOM.render(component, container)
        //(출력되는 요소, 출력되는 상자)
</script>
```

## 클래스 컴포넌트
_클래스 컴포넌트 만들기_
```
class 컴포넌트 이름 extends React.Component{
    render(){
        return <h1>출력할 것</h1>
    }
}
```
React.Component 클래스 : React.Component 클래스의 상속을 받아야 컴포넌트로 동작할 수 있게 하는 속성과 메소드를 받을 수 있음  
✔ 화면에 출력할 때 render( ) 메소드를 호출, 오버라이드해서 출력  
✔ 클래스 메소드 내부에서 this.props 속성 사용할 수 있음 (컴포넌트를 선언할 때 전달)

### 루트 컴포넌트 출력을 클래스 컴포넌트로 구현하기
_루트 컴포넌트 출력_
```js
const component = <h1> abc </h1>
const container = document.getElementById('root')

ReactDOM.render(component,container)
```
_클래스 컴포넌트_  (일반적으로 루트 컴포넌트는 App이라는 이름을 사용)
```js
//앱 클래스 생성하기
class App extends React.Component{
    render(){
        return <h1> abc </h1>
    }
}
//출력
const container=document.getElementById('root')
ReactDom.render(<App/>,container)
```

_this.props 사용하기_
```js
class App extends React.Component { 
    render() {
        return <div>
            <h1>{this.props.name} 님 Hi </h1>
            <img src={this.props.imgUrl}/>
            //컴포넌트의 속성으로 전달된 값을 사용
        </div>
    }
}
const container= document.getElementByid ('root')
ReactDOM.render(<App name="구름" imgUrl="http://img"/>,container)
//컴포넌트 속성 지정 
```

_클래스의 메소드 오버라이드 하기_
```js
class App extends React.Component{
    constructor (props){
        super(props) //부모 생성자 호출
        //생성자 코드 
    }
    render(){
        //출력할 것
    }
    componentDidMount(){
        //컴포넌트가 화면에 출력될 때 호출
    }
    componentWillUnmount(){
        //컴포넌트가 화면에서 제거될 때 호출
    }
}
//DidMount & WillUnmoount : 라이프사이클 메소드 / 컴포넌트가 내부적으로 특정상황에서 호출하는 메소드 
```

_state_  : 출력할 값 저장
_setState( ): state 속성 값을 변경할 때 &rarr; setState 메소드로 속성의 값을 변경하면 컴포넌트는 render()메소드를 호출해서 화면에 변경 사항 출력
```
//상태 선언하기(생성자 위치)
this.state={속성:값}
//상태 변경하기(이외의 위치)
this.setState({변경할 속성:값})
```

## 이벤트 연결하기
_컴포넌트에 이벤트 연결하기_ 예제 : 439page 
#### 형식1
```js
class App extends React.Component{
    constructor (props){
        super(props)
        this.메소드 이름 = this.메소드이름.bind(this) // -> 2번째 순서 : 메소드에 this 바인드 하기 ( 이 과정 없으면 event handler에서 this 입력했을 때 undefined나옴)
    }
    render(){
        return <h1 이벤트 이름={this.메소드 이름}></h1> // -> 3번째 순서 : 이벤트 연결
    }
    메소드 이름(event){
        //이벤트가 호출될 때 실행할 코드 -> 1번째 순서 : 메소드 선언하기
    }
}
```
#### 형식2
```js
class App extends React.Component{
    constructor (props){
        super(props)
        
    }
    render(){
        return <h1 이벤트 이름={this.메소드 이름}></h1>
        //+ex) //
        <button onClick={(e)=>this.countUp(e)}>클릭</button>
    }
    메소드 이름(event){
        //이벤트가 호출될 때 실행할 코드 -> 1번째 순서 : 메소드 선언하기
    }
}
```
#### 형식3
```js
class App extends React.Component{
    constructor (props){
        super(props)
        
    }
    render(){
        return <h1 이벤트 이름={this.메소드 이름}></h1>
    }
    메소드 이름=(event)=>{
    }
}
```
```countUP(event){ }```과 ```countUP=(event)=>{ }```의 차이  

```countUP(event){ }``` : 함수가 자체적인 this 값을 가짐 / 함수를 호출한 객체에 따라 this가 동적으로 결정  
```countUP=(event)=>{ }``` : 화살표 함수는 자신의 this값을 바인딩하지 않음. 주변 범위의 this값을 사용(주변 범위/상이 스코프의 this값을 상속받아 사용)

#### ✅this 바인딩
🟢this : this의 값은 함수를 <호출>하는 방법에 의해 결정됨 / 함수를 호출한 객체에 바인딩
✔ 화살표 함수는 자신의 실행 문맥 내에서 this 값을 바인딩하지 않고, 주변 범위의 실행 문맥(주로 함수를 정의한 컨텍스트)에서 this 값을 상속
✔ this의 값이 함수가 어떻게 호출되었는지에 개의치 않고 설정할 수 있는 것이 bind 메소드
🟢bind() : bind는 실행되는 함수의 this값을 원하는 특정 객체로 고정시켜주는 새로운 함수를 생성   
✔ bind()메소드를 호출하면 원본함수의 복사본이 만들어짐
✔ bind() 메서드의 첫 번째 인자로 전달된 객체가 바인딩된 함수의 this 값, 이후에 전달되는 인자들은 원본 함수의 매개변수로 전달




