1. (1) JSX
```js
// 리액트를 불러와서 사용, 
// 리액트 프로젝트를 만들 때 node_modules 디렉터리가 생성됌
// node_modules 디렉터리에 react 모듈이 설치됌
import React from 'react'；

--------------------------
function App() {
  return (
  <div className="App">
  <header className="App-header">
  <img src={logo} className="App-logo" alt="logo" />
    <p>
    Edit 〈code〉src/App.js〈/code〉 and save to reload.
  </p>
    <a
      className="App-link"
      href="https：//reactjs.org"
      target="_blank"
      rel="noopener noreferrer"
    >
      Learn React
    </a>
  </header>
  </div>
  );
}
// 이 코드는 App이라는 컴포넌트를 만들어 줌
// 이런 코드를 JSX라고 부름

-------------------------------------------

// JSX 코드가 변환하기 전
function App() {
return (
<div>
Hello 〈b〉react</b〉
</div>
)；
}

// 변환 후
function App() {
return React.createElement("div", null, "Hello ", React.createElement("b", null, "react"))；
}
```

2. JSX의 장점

- 보기 쉽고 익숙하다

- 더욱 높은 활용도

2. JSX 문법

- 규칙 1. 감싸인 요소

```js
// 오류 문법
import React from 'react';

function App() {
    return(
        <h1>리액트 안녕！</h1>
        <h2>잘 작동하니?</h2>
    )
}

export default App;

// 맞는 문법
import React from 'react';

function App() {
    return(
        <div>
            <h1>리액트 안녕！</h1>
            <h2>잘 작동하니?</h2>
        </div>
    )
}

export default App;

// 대체 가능
import React, { Fragment } from 'react';

function App() {
    return(
        <Fragment>
            <h1>리액트 안녕！</h1>
            <h2>잘 작동하니?</h2>
        </Fragment>
    )
}

export default App;

// 더 간단한 대체
import React from 'react';

function App() {
    return(
        <>
            <h1>리액트 안녕！</h1>
            <h2>잘 작동하니?</h2>
        </>
    )
}

export default App;
```

- 규칙 2. 자바스크립트 표현

`자바스크립트 표현식을 작성하려면 JSX 내부에서 코드를 { }로 감싸면 됌`

```js
import React from 'react';

function App() {
  const name = '리액트';
  return (
    <>
      <h1>{name}안녕！</h1>
      <h2>잘 작동하니?</h2>
    </>
  )
}

export default App;
```

- 규칙 3. If문 대신 조건부 연산자

`JSX 내부의 자바스크립트 표현식에서 if 문을 사용할 수는 없음`

`조건에 따라 다른 내용을 렌더링해야 할 때는 JSX 밖에서 if 문을 사용하여 사전에 값을 설정하거나, { } 안에 조건부연산자를 사용하면 됌`

```js
import React from 'react';

function App() {
  const name = '리액트';
  return (
    <div>
      {name === '리액트' ? (
        <h1>리액트입니다.</h1>) : (
        <h2>리액트가 아닙니다.</h2>
      )}
    </div>
  )
}

export default App;
```

- 규칙 4. AND 연산자(&&)를 사용한 조건부 렌더링

```js
import React from 'react';

function App() {
  const name = '리액트';
  return (
    <div>
      {name === '리액트' ? (
        <h1>리액트입니다.</h1>) : (
        <h2>리액트가 아닙니다.</h2>
      )}
    </div>
  )
}

export default App;
```

- 규칙 5. undefined를 렌더링하지 않기

`JSX 내부에서 사용할 수 있다고해도 굳이 사용해야할까 이걸`

- 규칙 6. 인라인 스타일링

` - 문자를 없애고 카멜 표기법 사용하기`

```js
import React from 'react';

function App() {
  const name = '리액트';
  return (
    <div
      style={{
        backgroundColor: 'black',
        color: 'aqua',
        fontSize: '48px',
        fontWeight: 'bold',
        padding: 16
      }}
    >
      {name}
    </div>
  )
}

export default App;
```

- 규칙 7. class 대신 className

```js
import React from 'react';

function App() {
  const name = '리액트';
  return (
    <div className='react'>{name}</div>
  )
}

export default App;
```

- 규칙 8. 꼭 닫아야 하는 태그

`그냥 태그를 잘 닫자`

- 규칙 9. 주석

`주석은 {/* … */}와 같은 형식으로 사용`

2. ESLint 와 Prettier

- ESLint는 문법 검사 도구이고, Prettier는 코드 스타일 자동 정리 도구

`그냥 이런 게 있구나아~ 나중에 필요하면 쓸게요.`

1. (2) 컴포넌트

2. 클래스형 컴포넌트

```js
import React, {Component} from 'react';

class App extends Component{
  render(){
    const name = 'react';
  return <div className='react'>{name}</div>
  }
}

export default App;
```

`클래스형 컴포넌트에서는 render 함수가 꼭 있어야 하고, 그 안에서 보여 주어야 할 JSX를 반환해야 함`

3. 함수형 컴포넌트의 장점

- 클래스형보다 선언하기가 편하다

- 메모리 자원을 클래스형보다 덜 사용

- 배포할 때도 결과물 파일 크기가 더 작음

3. 함수형 컴포넌트의 단점

- state와 라이프사이클 API의 사용이 불가능

- 이 단점들은 Hooks 기능으로 보완가능

2. 첫 컴포넌트 생성

` 파일 만들기 -> 코드 작성하기 -> 모듈 내보내기 및 불러오기 `

- src 디렉터리에 MyComponent.js 파일 생성

- 코드 작성

`함수형 컴포넌트를 선언할 때 function 키워드를 사용하는 것과 화살표 함수 문법을 사용하는 것 간에는 큰 차이가 없음`

-  모듈 내보내기 및 불러오기 

```js
// 모듈 내보내기
export default MyComponent;
```

```js
// 모듈 불러오기
import React from 'react';
import MyComponent from './MyComponent';
const App =()=>{
return <MyComponent/>;
};
export default App;
```

2. props

`properties를 줄인 표현으로 컴포넌트 속성을 설정할 때 사용하는 요소`

- JSX 내부에서 props 렌더링

```js
import React from 'react';
const MyComponent = props => {
return<div>안녕하세요, 제 이름은 {props.name}입니다.</div>;
};
export default MyComponent;
```

- 컴포넌트를 사용할 때 props 값 지정

```js
import React from 'react';
import MyComponent from './MyComponent1';
const App =()=>{
return <MyComponent name="React" />;
};
export default App;
```

- props 기본값 설정: defaultProps

```js
// App.js
import React from 'react';
import MyComponent from './MyComponent1';
const App =()=>{
return <MyComponent/>;
};
export default App;

// MyComponent.js
import React from 'react';
const MyComponent = props => {
return<div>안녕하세요, 제 이름은 {props.name}입니다.</div>;
};

MyComponent.defaultProps = {
name: '기본 이름'
};
export default MyComponen;
```

- 태그 사이의 내용을 보여 주는 children

```js
// App.js
import React from 'react';
import MyComponent from './MyComponent1';
const App =()=>{
return <MyComponent>리액트<MyComponent/>;
};
export default App;

// MyComponent.js
import React from 'react';
const MyComponent = props =〉 {
return (
<div>
안녕하세요, 제 이름은 {props.name}입니다. <br/>
children 값은 {props.children}
입니다.
</div>
);
};
MyComponent.defaultProps = {
name: '기본 이름'
};
export default MyComponent；
```

- 비구조화 할당 문법을 통해 props 내부 값 추출

```js
import React from 'react';
const MyComponent = props => {
const { name, children } = props;
return (
<div>
안녕하세요, 제 이름은 {name}입니다. <br/>
children 값은 {children}
입니다.
</div>
);
};
MyComponent.defaultProps = {
name: '기본 이름'
};
export default MyComponen;
```

` 방금 사용한, 객체에서 값을 추줄하는 문법을 비구조화 할당이라고 부름`

```js
import React from 'react';
const MyComponent = ({name, children}) => {
return (
<div>
안녕하세요, 제 이름은 {name}입니다. <br/>
children 값은 {children}
입니다.
</div>
);
};
MyComponent.defaultProps = {
name: '기본 이름'
};
export default MyComponen;
```

- propTypes를 통한 props 검증

` 컴포넌트의 필수 props를 지정하거나 props의 타입(type)을 지정할 때는 propTypes를 사용 `

```js
// MyComponent.js
import React from 'react';
import PropTypes from 'prop-types';
const MyComponent = ({ name, children }) => {
return (...);
};
MyComponent.defaultProps = {
name: '기본 이름'
};
MyComponent.propTypes = {
name: PropTypes.string
};
export default MyComponent;

// App.js
import MyComponent from './MyComponent1';
const App = () => {
return <MyComponent name="React">리액트</MyComponent>;
};
export default App;
```

- isRequired# 사용하여 필수 propTypes 설정

`propTypes를 지정하지 않았을 때 경고 메시지를 띄워 주는 작업`

```js
// MyComponent
import React from 'react';
import PropTypes from 'prop-types';
const MyComponent = ({ name, favoriteNumber, children }) => {
return (
<div>
안녕하세요, 제 이름은 {name}입니다. <br />
children 값은 {children}
입니다.
<br/>
제가 좋아하는 숫자는 {favoriteNumber}입니다.
</div>
);
};
MyComponent.defaultProps = {
name: '기본 이름'
};
MyComponent.propTypes = {
name: PropTypes.string,
favoriteNumber: PropTypes.number.isRequired
};
export default MyComponent;

// App.js 수정
import React from 'react';
import MyComponent from './MyComponent';
const App =()=>{
return (
<MyComponent name="React" favoriteNumber={1}>
리액트
</MyComponent>
);
};
export default App;
```

- 더 많은 PropTypes 종류

5. array： 배열

5. arrayOf(다른 PropType)： 특정 PropType으로 이루어진 배열을 의미

5. bool： true 혹은 false 값

5. func： 함수

5. number： 숫자

5. object： 객체

5. string： 문자열

5. symbol： ES6의 Symbol

5. node： 렌더링할 수 있는 모든 것

5. instanceOf(클래스): 특정 클래스의 인스턴스

5. oneOf(['dog', 'cat'])： 주어진 배열요소중 값하나

5. oneOfType([React.PropTypes.string, PropTypes.number] )： 주어진 배열 안의 종류 중 하나

5. objectOf(React.PropTypes.number)： 객체의 모든 키 값이 인자로 주어진 PropType인 객체

5. shape({ name： PropTypes.string, num： PropTypes.number })： 주어진 스키마를 가진 객체

5. any： 아무 종류

2. 클래스형 컴포넌트에서 props 사용

` 클래스형 컴포넌트에서 props를 사용할 때는 render 함수에서 this.props를 조회하면 됌 `

```js
import React, { Component } from 'react1';
import PropTypes from 'prop-types1';
class MyComponent extends Component {
render() {
const { name, favoriteNumber, children } = this.props； // 비구조화 할당
return (
<div>
안녕하세요, 제 이름은 {name}입니다. <br/>
children 값은 {children}
입니다.
<br/>
제가 좋아하는 숫자는 {favoriteNumber}입니다.
</div>
);
}
}
MyComponent.defaultProps = {
name: '기본 이름'
};
MyComponent.propTypes = {
name: PropTypes.string,
favoriteN니mber: PropTypes.number.isRequired
};
export default MyComponent;
```

` 클래스형 컴포넌트에서 defaultProps와 propTypes를 설정할 때 class 내부에서 지정하는 방법 `

```js
import React, { Component } from 'react';
import PropTypes from 'prop-types';
class MyComponent extends Component {
static defaultProps = {
name: '기본 이름'
};
static propTypes = {
name: PropTypes.string,
favoriteNumber: PropTypes.number.isRequired
};
render() {
const { name, favoriteNumber, children } = this.props; // H|구조화 할당
return (...);
}
}
export default MyComponent;
```

1. state

- 리액트에서 state는 컴포넌트 내부에서 바뀔 수 있는 값을 의미

2. 클래스형 컴포넌트의 state

```js
// Counter.js
import React, { Component } from 'react';;
class Counter extends Component {
constructor(props) {
super(props);
// state의 초깃값 설정하기
this.state = {
number: 0
};
}
render() {
const { number } = this.state; // state를 조회할 때는 this.state로 조회
return (
<div>
<h1>{number}</h1>
<button
// onClick을 통해 버튼이 클릭되었을 때 호출할 함수를 지정
onClick={() => {
// this.setstate를 사용하여 state에 새로운 값을 넣을 수 있음
this.setState({ number: number + 1 });
}}
>
+1
</button>
</div>
);
}
}
export default Counter;

// App.js
import React from 'react';
import Counter from './Counter';
const App = () => {
return <Counter />;
};
export default App;
```

3. state 객체 안에 여러 값이 있을 때

```js
import React, { Component } from 'react';
class Counter extends Component {
constructor(props) {
super(props);
// state의 초깃값 설정하기
this.state = {
number: 0,
fixedNumber: 0
};
}
render() {
const { number, fixedNumber } = this.state; // state를 조회할 때는 this.state로 조회합니다.
return (
<div>
<h1>{number}</h1>
<h2>바뀌지 않는 값: {fixedNumber}</h2>
<button
// onClick을 통해 버튼이 클릭되었을 때 호출할 함수를 지정합니다.
onClick={() => {
// this.setstate를 사용하여 state에 새로운 값을 넣을 수 있습니다.
this.setState({ number: number + 1 });
}}
>
+1
</button>
</div>
);
}
}
export default Counter;
```

3. state를 constructor에서 꺼내기

```js
import React, { Component } from 'react';
class Counter extends Component {
state = {
number: 0,
fixedNumber: 0
};
render() {
const { number, fixedNumber } = this.state; // state를 조회할 때는 this.state로 조회합니다.
return (...);
}
}
export default Counter;
```

3. his.setState에 객체 대신 함수 인자 전달하기

```js
<button
// onClick을 통해 버튼이 클릭되었을 때 호출할 함수를 지정합니다.
onClick={() => {
this.setState(prevState => {
return {number: prevState.number + 1
};
});
// 위 코드와 아래 코드는 완전히 똑같은 기능을 합니다.
// 아래 코드는 함수에서 바로 객체를 반환한다는 의미입니다.
this.setState(prevState => ({
number: prevState.number + 1
}));
}}
>
+1
</button>
```

3. this.setState가 끝난 후 특정 작업 실행

`setstate를 사용하여 값을 업데이트하고 난 다음에 특정 작업을 하고 싶을 때는 setstate의 두 번째 파라미터로 콜백(callback) 함수를 등록하여 작업을 처리가능`

```js
<button
// onClick을 통해 버튼이 클릭되었을 때 호출할 함수를 지정합니다.
onClick={() => {
this.setState(
{
number: number + 1
},
() => {
console.log(‘방금 setstate가 호출되었습니다. ,);
consol은.log(this.state);
}
);
}}
>
+1
</button>
```

2. 함수형 컴포넌트에서 useState 사용하기

3. 배열 비구조화 할당

`배열 안에 들어 있는 값을 쉽게 추출할 수 있도록 해 주는 문법`

```js
// 배열 비구조화 할당 전
const array = [1, 2];
const one = array[0];
const two = array[l];

// 배열 비구조화 할당 후
const array = [1, 2];
const [one, two] = array;
```

3. useState 사용하기

```js
// Say.js
import React, { useState } from 'react';
const Say =()=>{
const [message, setMessage] = useState('');
const onClickEnter = () => setMessage('안녕하세요!');
const onClickLeave = () => setMessage('안녕히 가세요!');
return (
<div>
<button onClick={onClickEnter}>입장</button>
<button onClick={onClickLeave}>퇴장</button>
<h1>{message}</h1>
</div>
);
};
export default Say;

// App.js
mport React from 'react';
import Say from './Say';
const App =()=>{
return <Say />;
};
export default App;
```

3. 한 컴포넌트에서 useState 여러 번 사용

```js
import React, { useState } from 'react';
const Say = () => {
const [message, setMessage] = useState('1');
const onClickEnter = () =〉setMessage('안녕하세요！');
const onClickLeave = () =〉setMessage('안녕히 가세요!');
const [color, setColor] = useState('black');
return (
<div>
<button onClick={onClickEnter}>입장</button>
<button onClick={onClickLeave}>퇴장</button>
<h1 style={{ color }}>{message}</h1>
<button style={{ color: 'red' }} onClick={() => setColor('red')}>
빨간색
</button>
<button style={{ color： 'green'}} onClick={() => setColor('green')}>
초록색
</button>
<button style={{ color: 'blue'}} onClick={() => setColor( 'blue')}>
파란색
</button>
</div>
);
};
export default Say;
```

1. state를 사용할 때 주의 사항

- state값을 바꾸어야 할 때는 setstate 혹은 useState를 통해 전달받은 세터 함수를 사용해야 함

```js
// 잘못된 코드

// 클래스형 컴포넌트에서…
this.state.number = this.state.number + 1;
this.state.array = this.array.push(2);
this.state.object.value = 5;
// 함수형 컴포넌트에서…
const [object, setObject] = useState({ a： 1, b： 1 });
object.b = 2;

// 배열이나 객체를 업데이트 하는 방법

// 객체 다루기
const object = { a: 1, b: 2, c: 3 };
const nextObject = {...object, b: 2 }; // 사본을 만들어서 b 값만 덮어 쓰기

// 배열 다루기
const array = [
{ id: 1, value: true },
{ id: 2, value: true },
{ id: 3, value: false }
];
let nextArray = array.concat({ id： 4 }); // 새 항목 추가
nextArray.filter(item => item.id !== 2); // id가 2인 항목 제거
nextArray.map(item => (item.id === 1 ? { ...item, value： false } : item));
// id가 1인 항목의 value를 false로 설정
```

- 객체에 대한 사본을 만들 때는 spread 연산자라 불리는 ...을 사용하여 처리

- 배열에 대한 사본을 만들 때는 배열의 내장 함수들을 활용