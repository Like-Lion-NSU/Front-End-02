# 9장

리액트에서 컴포넌트를 스타일링 하는 방식은 제각이다. 회사에서 요구하는 스펙이나 개발자가 선호하는 방식으로 선택하기 때문이다. 

사용하는 방식

    - 일반 css : 컴포넌트 스타일링의 가장 기본적인 방식

    - Sass : 자주 사용되는 css 전처리기 중 하나로 확장된 css 문법을 사용하여 css 코드를 더 쉽게 사용한다.

    - css module : 스타일링 작성시 css 클래스가 다른 css 클래스의 이름과 절대 충돌하지 않도록 파일마다 고유한 이름을 자동으로 생성

    - styled-components : 스타일을 js파일에 내장시키는 방식 스타일을 작성함과 동시에 해당 스타일이 적용된 컴포넌트 생성 가능    
    

--------
### css 

css 작성에서 가장 중요한 점은 css 클래스를 중복되지 않게 만드는 것. 이를 방지하기 위해 이름을 지을 때 특별한 규칙(BEM기법)을 사용하여 짓는 것, 다른 하나는 css selector(평소 사용하는 선택자를 이용)을 활용하는 것이다.

-------------

### Sass 사용하기

Sass는 css 전처리기로 복잡한 작업을 쉽게 처리하고, 코드의 재사용성을 높일 뿐만 아니라, 코드의 가독성을 올려 유지 보수를 쉽게 해준다.

Sass의 확장자는 .scss와 .sass를 지원한다. 둘의 문법은 꽤 차이가 있다.
```css
<!--sass-->
$font-stack: Helvetica, sans-serif
$primary-color : #333

body
    font : 100% $font-stack
    color: $primary-color


<!--scss-->
$font-stack: Helvetica, sans-serif;
$primary-color : #333;

body{
    font : 100% $font-stack;
    color: $primary-color;
}
```

.sass는 중괄화와 세미콜론을 사용하지 않는다. .scss는 기존 css와 비교해서 별 차이가 없다.

보통 .scss가 많이 사용된다.

----------

### utils 함수 분리하기
여러 파일에 사용할 수 있는 Sass의 변수 및 믹스인은 다른 파일로 따로 분리하여 작성한 뒤 필요한 곳에서 쉽게 불러올 수 있다.

* 믹스인(@mixin): 재사용되는 스타일 블록을 함수처럼 사용할 수 있음
--------
### sass-loader 설정 커스터마이징 하기
이 작업은 필수는 아니지만 해두면 유용하다. 파일을 불러올 때 경로를 import하여 불러오는데, 디렉토리를 많이 만들어서 구조가 깊어지면 한참 거슬러 올라가야 하는 경우가 있다. 이는 sass-loader의 설정을 커스터마이징하여 해결할 수 있다.

프로젝트 디렉토리에서 yarn eject 또는 npm eject를 해준다. 이는 세부설정을 밖으로 꺼내주는 것이다. 여기서 주의사항으로는 create-react-app은 기본적으로 git설정이 되어있다. eject명령어는 커밋이 되지 않은 것이 있다면 진행이 되지 않으니 커밋을 한 후 진행해야 한다.

eject 명령어를 실행했다면 config폴더가 생성된다. 안의 webpack.config.js를 열어 sassRegex라는 키워드를 찾는다. 그렇다면 두 번째 탐색결과에 이러한 결과가 나온다.

```css
{
    test: sassRegex,
    exlude: sassModuleRegex,
    use: getStyleLoaders(
        {
            importLoaders: 2,
            sourceMap : isEnvProduction && shouldUseSourceMap,
        },
        'sass-loader'
    ),
    sideEffects:true,
},
```
여기서 'sass-loader' 부분을 지우고, 뒷부분에 concat을 통해 커스터마이징된 sass-loader 설정을 넣어준다.

```css
{
    test: sassRegex,
    exlude: sassModuleRegex,
    use: getStyleLoaders(
        {
            importLoaders: 2,
            sourceMap : isEnvProduction && shouldUseSourceMap,
        }).concat({
            loader: require.resolve('sass-loader'),
            option: {
                sassOptions:{
                    includePaths:[paths.appSrc + '/styles']
                },
                sourceMap : isEnvProduction && shouldUseSourceMap,
                }
            }),
            sideEffects:true,
}
```

저장 후, 서버를 껏다가 재실행하면 불러올 파일의 상대적인 경로를 입력할 필요없이 파일의 이름을 import시켜주면 사용이 가능해진다.

import '파일명.scss' 이 한 줄을 적는것도 번거로울 수 있는데, 이때는 data 부분을 수정해주면 된다.

-------
### node_modules에서 라이브러리 불러오기
설치한 라이브러리를 불러오는 방법은 nodi_modules에서 해당 파일을 import시켜주는 방법이다.

그러나 파일명 앞에 ~를 적어주면 스타일을 바로 불러올 수 있다.

Sass 라이브러리

    include-media : 반응형 디자인을 위한 라이브러리
    open-color : 매우 편리한 색상 팔레트


### CSS MOUDULE

css moudule은 css를 불러와서 사용할 때 클래스 이름을 고유한 값, [파일이름]_[클래스 이름]__[해시값] 형태로 자동으로 만들어서 컴포넌트 스타일 클래스 이름이 중첩되는 현상을 방지하는 기술이다. '.module.css' 확장자로 파일을 저장하면 css module이 적용된다.

```css
/*CSSModule.module.css*/
/*자동으로 고유해질 것이므로 흔히 사용되는 단어를 클래스 이름으로 마음대로 시용 가능*/

.wrapper{
    background: black;
    padding : 1rem;
    color: white;
    font-size: 2rem;
}

/*글로벌 css를 작성하고 싶다면*/
:global .something{
    font-weight: 800;
    color : aqua;
}
```
css module을 사용하면 클래스 이름을 지을 때 그 고유성에 대해 고민하지 않아도 된다. 해당 클래스는 스타일을 직접 불러온 컴포넌트 내부에만 작동하기 때문이다.

css module을 적용한 파일을 불러오면 객체를 하나 전달 받는다. 해당 객체에는 css module에서 사용한 클래스 이름과 해당 이름을 고유화한 값이 키-값 형태로 들어있다.

- sass와 같이 사용할 수 있다.
- .module.scss로 확장자를 설정해주면 된다.
- :local을 사용하면 css module이 아닌 파일에서도 사용이 가능해진다.

-----------

### classnames
classnames는 css 클래스를 조건부로 설정할 때 매우 유용한 라이브러리이다. classnames라는 라이브러리를 설치해 줘야 한다. css module을 사용할 때 해당 라이브러리를 사용하면 여러 클래스를 적용할 때 매우 편리하다. props값에 따라 다른 스타일을 주기가 쉬워진다.

- page 238 ~ 239참고

### styled-components

CSS-in-JS라고 부르며 관련된 라이브러리가 많다.

개발자들이 가장 선호하는 라이브러리는 styled-components이다.
- styled-components를 대체할 수 있는 라이브러리는 emotion이 있다. 작동 방식은 비슷하다.

- 241~243쪽 참고

### 스타일링된 엘리먼트 만들기

styled-components를 사용하여 스타일링된 엘리먼트를 만들 땐느 컴포넌트 파일의 상단에 styled를 import시키고 styled.태그명을 사용하여 구현한다.

```css
import styled from 'styled-components';

const MyComponent = styled.div`
    font-size : 2rem;
 `;
 /*이렇게 하면 2rem의 font-size를 가진 div태그를 가진 MyComponent를 만들 수 있다.*/

 /*태그의 타입을 styled 함수의 인자로 전달*/
 const MyInput = styled('input')`
 background:gray;
 `
/*아예 컴포넌트 형식의 값을 넣어줌*/
const StyledLink = styled(Link)`
color:blue;
`
```

------
### 스타일에서 props 조회

styled-cmoponents를 통해 스타일 쪽에서 컴포넌트에게 전달된 props를 참조할 수 있다

```css
const Box = styled.div`
/*props로 넣어 준 값을 직접 전달이 가능*/
background: ${props => props.color || 'blue'};
padding : 1rem;
display: flex; 
`;
```

### props에 따른 조건부 스타일링, 반응형
p.248부터 참고, 앞의 내용들 적용이나 원래의 css와 거의 비슷함.

-------
# 10장
todo-app 참고

flexbox froggy