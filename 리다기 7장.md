1. 컴포넌트의 라이프사이클 메서드

- 모든 리액트 컴포넌트엔 라이프사이클 (수명주기) 가 존재함

- 컴포넌트의 수명은 페이지에 렌더링되기 전인 준비 과정에서 시작되서 페이지에서 사라질 때 끝남

1 - 1. `라이프사이클`

- 라이프사이클은 마운트, 업데이트, 언마운트로 나뉨

- 라이프사이클 메서드의 종류는 총 9가지

- Will 접두사가 붙은 메소드는 작동하기 전, Did 접두사가 붙은 메소드는 작동 이후에 실행

1 - 1 - 1. `마운트` : DOM이 생성되고 웹 브라우저상에 나타나는 것

**마운트 할 때 호출하는 메서드**

컴포넌트 만들기 -> constructor -> getDerivedStateFromProps -> render -> componentDidMount

- constructor : 컴포넌트를 새로 만들 때마다 호출되는 클래스 생성자 메서드

- getDerivedStateFromProps : props에 있는 값을 state에 넣을 때 사용하는 메서드

- render : 우리가 준비한 UI를 렌더링하는 메서드

- componentDidMount : 컴포넌트가 웹 브라우저상에 나타난 후 호출하는 메서드

1 - 1 - 2. `업데이트` : 컴포넌트는 다음과 같은 4가지 경우에 업데이트를 함

- props가 바뀔 때 , state가 바뀔 때 , 부모 컴포넌트가 리렌더링될 때 , this.forceUpdate로 강제로 렌더링을 트리거할 때

**업데이트 할 때 호출하는 메서드**

업데이트 발생 요인 -> getDerivedStateFromProps -> shouldComponentUpdate -> render -> getSnapshotBeforeUpdate -> componentDidUpdate

- shouldComponentUpdate : 컴포넌트가 리렌더링을 해야 할지 말아야 할지 결정하는 메서드 ( true or false 반환 ) `만약 특정 함수에서 this.forceUpdate() 함수를 호출하면 과정 생략 후 render`

- getSnapshotBeforeUpdate : 컴포넌트 변화를 DOM에 반영하기 바로 직전에 호출하는 메서드

- componentDidUpdate : 컴포넌트의 업데이트가 끝난 후 호출되는 메서드

1 - 1 - 3. `언마운트` : 컴포넌트를 DOM에서 제거하는 것

**언마운트 할 때 호출하는 메서드**

언마운트하기 -> componentWillUnmount

- componentWillUnmount : 컴포넌트가 웹 브라우저상에서 사라지기 전에 호출하는 메서드

1 - 2. `라이프사이클 메서드`

1 - 2 - 1. `render()` - render() { ... }

 - 컴포넌트 모양새를 정의

 - this.props , this.state에 접근 가능하며 리액트 요소 반환 ( 요소는 태그가 될 수 있고 따로 선언한 컴포넌트가 될 수도 있음 )

1 - 2 - 2. `constructor()` - constructor(props) { ... }

 - 컴포넌트 생성자 메서드로 컴포넌트를 만들 때 처음으로 실행

 - 초기 state 지정 가능

1 - 2 - 3. `getDerivedStateFromProps()`

 - props로 받아 온 값을 state에 동기화시키는 용도로 사용

1 - 2 - 4. `componentDidMount()` - componentDidMount() { ... }

 - 컴포넌트를 만들고, 첫 렌더링을 다 마친 후 실행 ( 다른 자바스크립트 라이브러리 or 프레임워크의 함수를 호출 or 비동기 작업 처리)

1 - 2 - 5. `shouldComponentllpdate()` - shouldComponentUpdate(nextProps, nextState) { ... }

 - props 또는 state를 변경했을 때 리렌더링을 시작할지 여부를 지정하는 메서드

1 - 2 - 6. `getSnapshotBeforellpdate()`
 
 - render에서 만들어진 결과물이 브라우저에 실제로 반영되기 직전에 호출

1 - 2 - 7. `componentDidUpdate()` - componentDidUpdate(prevProps, prevState, snapshot) { ... }

 - 리렌더링을 완료한 후 실행

1 - 2 - 8. `componentWillUnmount()` - componentWillUnmount() { ... }

 - 컴포넌트를 DOM에서 제거할 때 실행

1 - 2 - 9. `componentDidCatch()`
 
 - 컴포넌트 렌더링 도중에 에러가 발생했을 때 애플리케이션이 먹통이 되지 않고 오류 UI를 보여 줄 수 있게 해줌

```js
// LifeCycleSample.js

import React, { Component } from 'react';

class LifeCycleSample extends Component{
    state = {
        number: 0,
        color: null,
    }

    myRef = null;   // ref를 설정할 부분

    constructor(props){
        super(props);
        console.log('constructor'); // 컴포넌트 만들면 제일 먼저 실행
    }

    static getDerivedStateFromProps(nextProps, prevState){
        console.log(getDerivedStateFromProps);
        if(nextProps.color !== prevState.color){
            return {color: nextProps.color};        // 전 색상과 현 색상이 맞지 않으면 현 색상으로 리턴
        }
        return null;
    }

    componentDidMount(){
        console.log('componentDidMount');
    }

    shouldComponentUpdate(nextProps, nextState){
        console.log('shouldComponentUpdate', nextProps, nextState);
        return nextState.number % 10 !== 4;         // 렌더링이 4로 끝나면 리렌더링 취소
    }

    componentWillUnmount(){
        console.log('componentWillUnmount');
    }

    handleClick = () => {
        this.setState({
            number: this.state.number + 1           // 핸들클릭 발생 시 숫자 + 1
        });
    }

    getSnapshotBeforeUpdate(prevProps, prevState){
        console.log('getSnapshotBeforeUpdate');
        if(prevProps.color !== this.props.color){
            return this.myRef.style.color;          // DOM에 변화가 일어나기 직전의 색상 속성을 snapshot 값으로 반환하여 이것을 componentDidUpdate에서 조회
        }
        return null;
    }

    componentDidUpdate(prevProps, prevState, snapshot){
        console.log('componentDidUpdate', prevProps, prevState);
        if(snapshot){
            console.log('업데이트 되기 직전 색상: ', snapshot);
        }
    }

    render(){
        console.log('render');

    const style = {
        color: this.props.color
    };

    return (
        <div>
         <h1 style = {style} ref = {ref => this.myRef=ref}>
            {this.state.number}
         </h1>
         <p>color: {this.state.color}</p>
         <button onClick = {this.handleClick}>
            더하기
         </button>
        </div>
        )
    }
}

export default LifeCycleSample;

// App.js

import React, { Component } from 'react';
import LifeCycleSample from './LifeCycleSample';

// 랜덤 색상을 생성합니다.
function getRandomColor() {
    return '#' + Math.floor(Math.random() * 16777215),toString(16);
}

class App extends Component {
    state = {
        color: '#000000'
        }

    handleclick =()=>{
        this.setState({
            color: getRandomColor()
            });
        }
    render() {
    
        return (
            <div>
                <button onClick={this.handleClick}>랜덤 색상</button>
                <LifeCycleSample color={this.state.color}/>
            </div>
        );
    }
}
export default App;
```

1 - 3. 에러 잡아내기

```js
// ErrorBoundary.js

import React, { Component } from 'react';

class ErrorBoundary extends Component {
    state = {
        error: false
    };
    componentDidCatch(error, info){
        this.setState({
            error: true
        });
        console.log({error, info});
    }
    render(){
        if (this.state.error) return <div>에러가 발생했습니다!</div>
        return this.props.children;
    }
}
export default ErrorBoundary;
```